
%% Riemannian Subgradient Synchronization Algorithm

%% Input parameter:
%% Ind: edge_num by 2 "edge indices matrix". Each row is the index of an edge (i,j). that is sorted as (1,2), (1,3), (1,4),... (2,3), (2,4),.... 
%% edge_num is the number of edges.
%% RijMat: 3 by 3 by edge_num tensor that stores the given relative rotations corresponding to Ind
%% R_ini: initial point generated by other algorithms
%% R_orig: groundtruth rotations (to compute the estimation error in each step)

%% ReSync_parameters.max_iter: the maximal number of iterations of ReSync
%% ReSync_parameters.stepsize: the initial stepsize
%% ReSync_parameters.decay: the decay ratio of stepsize
%% ReSync_parameters.stop_threshold: the stopping criterion

%% Output:
%% R_est: estimated rotations (d*d*n)
%% Dist: teh sequence of dist(R_est^k, R_orig) for each iterate 




function [R_est, Dist] = ReSync(Ind , RijMat, R_ini, R_orig, ReSync_parameters)

R_est = R_ini;
[d, ~, n] = size(R_ini);

Ind_i = Ind(:,1);
Ind_j = Ind(:,2);

m=size(Ind_i,1);
Dist = [];

for iter = 1 : ReSync_parameters.max_iter
    % linear decay of stepsize
    step = ReSync_parameters.stepsize * ReSync_parameters.decay^(iter);
    
    % compute the subgradient using sparse representation of RijMat
    sub_grad = zeros(d, d, n);
    for k = 1 : m
        i = Ind_i(k); j=Ind_j(k);
        diff_ij =  eye(d) - R_est(:,:,i)' * RijMat(:,:,k) * R_est(:,:,j);
        tmp_ij = norm(diff_ij,'fro'); 
        if tmp_ij > 1e-12
            sub_grad(:,:,i) = sub_grad(:,:,i) + diff_ij/tmp_ij;
            sub_grad(:,:,j) = sub_grad(:,:,j) + diff_ij'/tmp_ij;
        end
    end

    
    x_err = zeros(d);
    for i = 1 : n
        xi = R_est(:,:,i);
        x_err = x_err + xi' * R_orig(:,:, i); % compute the error in each step
        x_egrad_i = xi * (sub_grad(:,:,i) - sub_grad(:,:,i)'); % Riemannian subgradient
        
        y = xi -step* x_egrad_i; 
        [Q_y, R_y] = qr(y); 
        xi = Q_y * diag(sign(sign(diag(R_y))+.5));  % qr-based retraction
        R_est(:,:,i) = xi;
    end

    % compute the distance to groundtruch R_orig
    [Ur,Lr,Vr] = svd(x_err);
    S0 = diag([ones(1,d-1),det(Ur*Vr')]);
    dist = real(sqrt(2*d - 2*sum(sum(Lr.*S0)) / n));
    if mod(iter, 10) == 1
        fprintf('estimation error: %d in iteration %d \n',dist, iter); 
    end

    if step < ReSync_parameters.stop_threshold
        break;
    end
    Dist = [Dist, dist];
end